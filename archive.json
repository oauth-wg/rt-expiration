{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-12-21T01:06:36.215874+00:00",
  "repo": "oauth-wg/rt-expiration",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOOTpjy862Gb4-",
      "title": "Test Issue",
      "url": "https://github.com/oauth-wg/rt-expiration/issues/1",
      "state": "CLOSED",
      "author": "njwatson32",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-05-11T18:25:10Z",
      "updatedAt": "2025-11-11T07:36:49Z",
      "closedAt": "2025-11-11T07:36:49Z",
      "comments": []
    },
    {
      "number": 2,
      "id": "I_kwDOOTpjy87CDi_S",
      "title": "Necessity of this draft",
      "url": "https://github.com/oauth-wg/rt-expiration/issues/2",
      "state": "CLOSED",
      "author": "yaron-zehavi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Dear Nick,\nI think the proposed parameters `refresh_token_expires_in`, `consent_expires_in` makes explicit what today works well, although implicitly.\n\n- `refresh_token_expires_in`: Currently token endpoint responds with `expires_in` which refers to the `access_token`, and the assumption is that when expiration time is reached, client shall use the optional `refresh_token` to renew. So there's an implicit assumption that the TTL of `refresh_token` is longer than that of the `access_token`. That's a pretty strong assumption because if the refresh token has same or shorter TTL as the access token, it's rendered useless.\n- `consent_expires_in`: Clients refresh consents as long as they are successful in doing so. The RFC6749 error `invalid_grant` is intended, among others, for expired consents: \"The provided authorization grant (e.g., authorization code, resource owner credentials) or **refresh token** is invalid, **expired**, revoked\"\n",
      "createdAt": "2025-07-23T09:54:22Z",
      "updatedAt": "2025-07-23T17:27:03Z",
      "closedAt": "2025-07-23T17:27:03Z",
      "comments": [
        {
          "author": "njwatson32",
          "authorAssociation": "COLLABORATOR",
          "body": "- `refresh_token_expires_in`: There are lots of clients that use their access infrequently, and may only refresh the token when needed. `lifetime(RT) >= lifetime(AT)` is indeed obvious, but that's insufficient information for clients that, say, only use their RT when the user is using the app.\n- `consent_expires_in`: This one is needed for the reasons mentioned in the draft. Users can extend consent out of band to avoid an interruption in service. Waiting for expiration first is a very bad experience. Google has had several large clients ask us to return this information.",
          "createdAt": "2025-07-23T10:59:18Z",
          "updatedAt": "2025-07-23T10:59:18Z"
        },
        {
          "author": "yaron-zehavi",
          "authorAssociation": "NONE",
          "body": "hmmm good points.\n1. I think it could be argued that clients that only use their RT when the user is present, are liable to also ignore `refresh_token_expires_in`. And more diligent clients that renew access no matter what, do so on the TTL of AT)\n2. What's the value of `consent_expires_in` when it's lifetime is subject to shortening or extension out of band? Assuming the consent_expires_in valeu doesn't change, what would client do with this information?",
          "createdAt": "2025-07-23T15:05:15Z",
          "updatedAt": "2025-07-23T15:05:15Z"
        },
        {
          "author": "njwatson32",
          "authorAssociation": "COLLABORATOR",
          "body": "1. I don't think this follows. I would think the opposite, in fact. Clients that only use the RT rarely would now know that they need to use it at a particular cadence. If they don't bother to implement anything, that's their call, but we need to at least give them the info to make that choice. Otherwise they're likely to either assume the RT lasts forever, potentially resulting in a bad experience, or refresh every hour even if unneeded, which is wasteful.\n2. The value can change. I can't think of a case when it would be shortened, as users would be likely to just revoke rather than shorten. Lengthening is useful to communicate to the client. If clients with \"offline\" use cases (e.g. email monitoring) detect that the duration is coming to an end, they want to proactively remind the user to extend consent.",
          "createdAt": "2025-07-23T16:49:36Z",
          "updatedAt": "2025-07-23T16:49:36Z"
        },
        {
          "author": "yaron-zehavi",
          "authorAssociation": "NONE",
          "body": "Thanks,\nI see your point on #1 and agree.\nAs for #2 maybe `consent_expires_in` should be returned also on subsequent calls to token endpoint with refresh token, allowing client to learn if consent has been prolonged.",
          "createdAt": "2025-07-23T17:26:56Z",
          "updatedAt": "2025-07-23T17:26:56Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOOTpjy87WtYHY",
      "title": "Complexity in authorization lifetimes being bound to scopes",
      "url": "https://github.com/oauth-wg/rt-expiration/issues/4",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This issue of authorizations being bound to scopes is called out in the spec but not really addressed. \n\n> Tying authorization lifetime to scopes means it's possible to have some access valid for one duration and other access valid for a different duration. For example, a user could grant indefinite access for the openid scope and short-lived access for a calendar scope.\n\nThe spec also refers to the use of RAR which could generate a very short lived token (say 10 mins) but the system sets the access token expiry to be a minute so the client has to get a new access token via the refresh_token grant. Following this spec then the refresh_token MUST expire in 10 mins.\n\n",
      "createdAt": "2025-11-07T22:17:34Z",
      "updatedAt": "2025-11-11T17:12:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "njwatson32",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I probably should slightly open this can of worms, if only to acknowledge that it's a can of worms and make a recommendation. I'd lean to say that the AS SHOULD return the minimum expiration time across all scopes.\n\nFor RAR, what would cause the refresh token to have 10-minute validity? User choice, system policy, client request, something else?",
          "createdAt": "2025-11-11T07:49:11Z",
          "updatedAt": "2025-11-11T07:49:11Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "NONE",
          "body": "Here is a possible example.\n\nThe RAR request is about depositing money into an account. The authorization for this particular request is 10mins. The AS also responds with a RT and AT where the AT expires in 1 min. The client can then use the RT to get a new AT for another deposit without requiring user authorization up to 10 mins.\n\nIf I'm understanding the specification correctly, the authorization_expires_in is set to 10 mins so the refresh_token MUST also expire in 10 mins. Within those 10mins the client can request as many \"deposit funds\" access tokens as it likes without requiring additional user confirmation. \n\nHow to handle these nuances should be out of scope for the spec. I'm just concerned we may run into cases where we are making the user experience worse rather than better. Some guidance or considerations I think are useful to help clients navigate the UX challenges.\n\nBasically, if the client requests many scopes, it's likely going to run into issues if the AS is managing authorizations differently for each scope. As a user I'd probably try and figure out how to set all the authorization lifetimes to be the same value (if I could figure it out:).",
          "createdAt": "2025-11-11T17:12:04Z",
          "updatedAt": "2025-11-11T17:12:04Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOOTpjy87WtboO",
      "title": "Are clients expected to manage only a single refresh_token per AS?",
      "url": "https://github.com/oauth-wg/rt-expiration/issues/5",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm wondering if one way to deal with the issue that the client may be required to prompt the user for new authorization more than desired is to allow the client to manage multiple refresh_tokens making the relationship between refresh_tokens and issued scopes closer to 1:1. \n\nA user may want to authorize explicitly access to their financial data (authorization time = 10 mins) but the client doesn't need the financial data very often so it lets that associated refresh_token expire and only when the user choses to see that data via the UI then goes through the flow to get a new token.\n\nIf the client can manage different sets of scopes by managing multiple refresh_tokens it allows the better management of the user experience.",
      "createdAt": "2025-11-07T22:22:05Z",
      "updatedAt": "2025-11-11T16:54:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "njwatson32",
          "authorAssociation": "COLLABORATOR",
          "body": "The direct answer to your title question is \"no, clients can decide how many RTs they want to manage\", but I think there's a tradeoff here. If the client wants multiple RTs, that's typically going to be multiple round trips through the AS that require user interaction, which may be cumbersome. But as you say, it will ultimately result in better client control over managing expiration.\n\nI could mention this tradeoff in UX Considerations.",
          "createdAt": "2025-11-11T07:45:59Z",
          "updatedAt": "2025-11-11T07:45:59Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "NONE",
          "body": "That sounds good. I like the new values as basically just stating claims about the RT and minimum authorization refresh time and then letting the client determine how to best manage the UX for their app. For some clients just managing a single RT and re-authorization may work file. For others, I think it's going to get complicated and they may need to take a more sophisticated solution.",
          "createdAt": "2025-11-11T16:54:31Z",
          "updatedAt": "2025-11-11T16:54:31Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOOTpjy87Wtd6C",
      "title": "Is the user required to \"re-authorize\" the client via a client initiated flow?",
      "url": "https://github.com/oauth-wg/rt-expiration/issues/6",
      "state": "OPEN",
      "author": "gffletch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the case of say a background task which I've authorized to read my mail and the AS determines that I must \"re-authorize\" every 30 days, is it possible that I could just go to the mail service and re-authorize there rather than having to go through the client's initiated OAuth flow? \n\nIf this become a common pattern I might have multiple clients that are accessing multiple resources protected by the AS, and it would be easier for me to go to the AS and re-authorize them all at the AS rather than going through a new OAuth flow for each client.",
      "createdAt": "2025-11-07T22:25:07Z",
      "updatedAt": "2025-11-11T16:50:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "njwatson32",
          "authorAssociation": "COLLABORATOR",
          "body": "This is something the user would have to do at the AS because it's the AS that controls the underlying credentials that would need updating. Whether or not it's user-initiated or client-initiated seems like it should be out of scope for normative parts of the spec, though I think it's probably reasonable to mention this in the UX Considerations section. WDYT?",
          "createdAt": "2025-11-11T07:39:50Z",
          "updatedAt": "2025-11-11T07:39:50Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "NONE",
          "body": "Yes, I think putting something in the UX Considerations makes sense. The core spec does say that the authorization can be updated out of band.",
          "createdAt": "2025-11-11T16:50:33Z",
          "updatedAt": "2025-11-11T16:50:33Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDOOTpjy86gkDMZ",
      "title": "fix section reference",
      "url": "https://github.com/oauth-wg/rt-expiration/pull/3",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-07-25T04:05:26Z",
      "updatedAt": "2025-07-25T04:05:26Z",
      "baseRepository": "oauth-wg/rt-expiration",
      "baseRefName": "main",
      "baseRefOid": "ef58e6762bb31088ba5b986dcc2cb1347b2719b7",
      "headRepository": "oauth-wg/rt-expiration",
      "headRefName": "aaronpk-patch-1",
      "headRefOid": "427c784b4a77ff705aebb844e9bd3c80e85a3c3e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}